% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hypergeo.R
\name{genhypergeo}
\alias{genhypergeo}
\title{Generalized hypergeometric function}
\usage{
genhypergeo(
  U,
  L,
  z,
  prec = NULL,
  check_mode = TRUE,
  log = FALSE,
  backend = c("mpfr", "gmp")
)
}
\arguments{
\item{U, L}{List of numeric vectors for upper and lower values.}

\item{z}{Numeric vector as common ratios.}

\item{prec}{List of \code{NULL} or (unsigned) integers as precision level during computation,
a.k.a the number of precise digits of floating-point datatypes.
This argument is vectorized: you may use different precision settings for different input elements.
If \code{NULL}, double precision (default) is used.}

\item{check_mode}{Logical vector indicating whether the mode of \code{x}
should be checked for obvious convergence failures.
This argument is vectorized: you may use different check modes for different input elements.}

\item{log}{Logical (1L) indicating whether result is given as log(result).
This argument is \strong{NOT} vectorized: only its first element is used.}

\item{backend}{One of the following: "mpfr" (default) or "gmp", for the realization of
floating-point datatype of tunable precision. This argument is \strong{NOT} vectorized:
you may only input character (1L).}
}
\value{
Numeric vector as the results of computation (at \code{double} precision).
Warnings are issued if failing to converge.
}
\description{
\code{genhypergeo} computes generalized hypergeometric function with vectorized input.
This function is available in \code{\link[Rcpp:Rcpp-package]{Rcpp}}
as \code{hypergeo2::genhypergeo_vec()}. Its non-vectorized version is available in
\code{\link[Rcpp:Rcpp-package]{Rcpp}} as \code{hypergeo2::genhypergeo_vec()}.
To use them, please use \code{[[Rcpp::depends(hypergeo2)]]} and \code{#include "hypergeo2.h"}.
}
\details{
Sometimes, computing generalized hypergeometric function in double precision is not sufficient,
even though we only need 6-8 accurate digits in the results (see example). Here, two floating-point
datatypes are provided: \code{mpfr_float} ("mpfr") and \code{gmp_float} ("gmp"). By comparison,
the "mpfr" backend is safer, since it defines \code{Inf} while the "gmp" backend throws overflow
exception (see references). But the "gmp" backend results in more accurate results at the same precision,
since it usually uses higher precision than set (see reference and validate it on yourself with the examples).
}
\note{
Change log:
\itemize{
\item{0.1.0 Xiurui Zhu - Initiate the function.}
}
}
\examples{
U <- c(-28.2, 11.8, 15.8)
L <- c(12.8, 17.8)
z <- 1
# hypergeo results
if (length(find.package("hypergeo", quiet = TRUE)) > 0L) {
  hypergeo::genhypergeo(U = U, L = L, z = z)
}
# Default (double) precision
genhypergeo(U = U, L = L, z = z)
# Precision of 20 digits, default (mpfr) backend
genhypergeo(U = U, L = L, z = z, prec = 20L)
# Precision of 20 digits, gmp backend
genhypergeo(U = U, L = L, z = z, prec = 20L, backend = "gmp")
# Precision of 25 digits, default (mpfr) backend
genhypergeo(U = U, L = L, z = z, prec = 25L)
# Precision of 25 digits, gmp backend
genhypergeo(U = U, L = L, z = z, prec = 25L, backend = "gmp")
}
\references{
For the floating-point datatypes of tunable precision:
\itemize{
\item Documentation about \href{https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/mpfr_float.html}{\code{mpfr_float}}
\item Documentation about \href{https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/gmp_float.html}{\code{gmp_float}}
\item Documentation about \href{https://www.mpfr.org/faq.html#:~:text=What\%20are\%20the\%20differences\%20between\%20MPF\%20from\%20GMP,minimum\%20value\%20\%28MPF\%20generally\%20uses\%20a\%20higher\%20precision\%29}{"gmp"'s higher precision}
}
}
\author{
Xiurui Zhu
}
