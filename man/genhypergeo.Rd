% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hypergeo.R
\name{genhypergeo}
\alias{genhypergeo}
\title{Generalized hypergeometric function}
\usage{
genhypergeo(
  U,
  L,
  z,
  prec = NULL,
  check_mode = TRUE,
  log = FALSE,
  backend = c("mpfr", "gmp")
)
}
\arguments{
\item{U, L}{List of numeric vectors for upper and lower values.}

\item{z}{Numeric vector as common ratios.}

\item{prec}{List of \code{NULL} or (unsigned) integers as precision level during computation,
a.k.a the number of precise digits of floating-point datatypes.
This argument is vectorized: you may use different precision settings for different input elements.
If \code{NULL}, double precision (default) is used.}

\item{check_mode}{Logical vector indicating whether the mode of \code{x}
should be checked for obvious convergence failures.
This argument is vectorized: you may use different check modes for different input elements.}

\item{log}{Logical (1L) indicating whether result is given as log(result).
This argument is \strong{NOT} vectorized: only its first element is used.}

\item{backend}{One of the following: 'mpfr' (default) or 'gmp', for the realization of
floating-point datatype of tunable precision. This argument is \strong{NOT} vectorized:
you may only input character (1L).}
}
\value{
Numeric vector as the results of computation (at \code{double} precision).
Warnings are issued if failing to converge.
}
\description{
\code{genhypergeo} computes generalized hypergeometric function with vectorized input.
}
\details{
Sometimes, computing generalized hypergeometric function in double precision is not sufficient,
even though we only need 6-8 accurate digits in the results (see example). Here, two floating-point
datatypes are provided: \code{mpfr_float} ('mpfr') and \code{gmp_float} ('gmp'). By comparison,
the 'mpfr' backend is safer, since it defines \code{Inf} while the 'gmp' backend throws overflow
exception (see references). But the 'gmp' backend results in more accurate results at the same precision,
since it usually uses higher precision than set (see reference and validate it on yourself with the examples).

\code{genhypergeo} is available in \code{\link[Rcpp:Rcpp-package]{Rcpp}}
as \code{hypergeo2::genhypergeo_vec()}; its non-vectorized version is named
in \code{\link[Rcpp:Rcpp-package]{Rcpp}} as \code{hypergeo2::genhypergeo_cpp()}.

Its non-vectorized version is available in
\code{\link[Rcpp:Rcpp-package]{Rcpp}} as \code{hypergeo2::genhypergeo_<int SXP, typename T1, typename T2>()},
where \code{SXP} is the type of \code{Rcpp::Vector}, \code{T1} is the input/output datatype
and \code{T2} is the datatype used in computation (see references for example datatypes).

To use them, please use \code{[[Rcpp::depends(hypergeo2)]]} and \code{#include <hypergeo2.h>}
in your C++ source files, and add \code{@importFrom hypergeo2 genhypergeo}
to \code{R/*-package.R} file, just like \code{\link[Rcpp:Rcpp-package]{Rcpp}}.
}
\note{
Change log:
\itemize{
\item{0.1.0 Xiurui Zhu - Initiate the function.}
}
}
\examples{
U <- c(-28.2, 11.8, 15.8)
L <- c(12.8, 17.8)
z <- 1
# hypergeo results
if (length(find.package("hypergeo", quiet = TRUE)) > 0L) {
  hypergeo::genhypergeo(U = U, L = L, z = z)
}
# Default (double) precision: this may result in cancellation error on some platforms
tryCatch(
  genhypergeo(U = U, L = L, z = z),
  error = function(err) {
    if (grepl("Cancellation is so severe that no bits in the result are correct",
              conditionMessage(err)) == TRUE) {
      message("! Cancellation error on your platform: ",
              "you may need a higher [prec] than double ([prec = NULL]): ",
              conditionMessage(err))
    } else {
      stop(err)
    }
  }
)
# Precision of 20 digits, default ('mpfr') backend
genhypergeo(U = U, L = L, z = z, prec = 20L)
# Precision of 20 digits, 'gmp' backend
genhypergeo(U = U, L = L, z = z, prec = 20L, backend = "gmp")
# Precision of 25 digits, default ('mpfr') backend
genhypergeo(U = U, L = L, z = z, prec = 25L)
# Precision of 25 digits, 'gmp' backend
genhypergeo(U = U, L = L, z = z, prec = 25L, backend = "gmp")
}
\references{
For the floating-point datatypes of tunable precision:
\itemize{
\item Documentation about \href{https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/mpfr_float.html}{\code{mpfr_float}},
with datatype \code{boost::multiprecision::number<boost::multiprecision::backends::mpfr_float_backend<0>>}
\item Documentation about \href{https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/gmp_float.html}{\code{gmp_float}},
with datatype \code{boost::multiprecision::number<boost::multiprecision::backends::gmp_float<0>>}
\item Documentation about \href{https://www.mpfr.org/faq.html#:~:text=What\%20are\%20the\%20differences\%20between\%20MPF\%20from\%20GMP,minimum\%20value\%20\%28MPF\%20generally\%20uses\%20a\%20higher\%20precision\%29}{higher precision of \code{gmp_float} datatype}
}
}
\author{
Xiurui Zhu
}
