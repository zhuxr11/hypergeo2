#' Generalized hypergeometric function
#'
#' \code{genhypergeo} computes generalized hypergeometric function with vectorized input.
#'
#' @param U,L List of numeric vectors for upper and lower values.
#' @param z Numeric vector as common ratios.
#' @param prec List of \code{NULL} or (unsigned) integers as precision level during computation,
#' a.k.a the number of precise digits of floating-point datatypes.
#' This argument is vectorized: you may use different precision settings for different input elements.
#' If \code{NULL}, double precision (default) is used.
#' @param check_mode Logical vector indicating whether the mode of \code{x}
#' should be checked for obvious convergence failures.
#' This argument is vectorized: you may use different check modes for different input elements.
#' @param log Logical (1L) indicating whether result is given as log(result).
#' This argument is **NOT** vectorized: only its first element is used.
#' @param backend One of the following: 'mpfr' (default) or 'gmp', for the realization of
#' floating-point datatype of tunable precision. This argument is **NOT** vectorized:
#' you may only input one of the backends.
#'
#' @details
#' Sometimes, computing generalized hypergeometric function in double precision is not sufficient,
#' even though we only need 6-8 accurate digits in the results (see example). Here, two floating-point
#' datatypes are provided: \code{mpfr_float} ('mpfr') and \code{gmp_float} ('gmp'). By comparison,
#' the 'mpfr' backend is safer, since it defines \code{Inf} while the 'gmp' backend throws overflow
#' exception (see references). But the 'gmp' backend results in more accurate results at the same precision,
#' since it usually uses higher precision than set (see reference and validate it on yourself with the examples).
#'
#' \code{genhypergeo} is available in \code{\link[Rcpp:Rcpp-package]{Rcpp}}
#' as \code{hypergeo2::genhypergeo_vec()}; its non-vectorized version is named
#' in \code{\link[Rcpp:Rcpp-package]{Rcpp}} as \code{hypergeo2::genhypergeo_cpp()}.
#'
#' If a custom backend (e.g. [\code{cpp_bin_float}](https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_bin_float.html))
#' is to be used, the underlying templated function is available in \code{\link[Rcpp:Rcpp-package]{Rcpp}}
#' as \code{hypergeo2::genhypergeo_<int SXP, typename T1, typename T2>()},
#' where \code{SXP} is the type of \code{Rcpp::Vector}, \code{T1} is the input/output datatype
#' and \code{T2} is the datatype used in computation (see references for example datatypes).
#'
#' To use them, please use \code{[[Rcpp::depends(hypergeo2)]]} and \code{#include <hypergeo2.h>}
#' in your C++ source files, and add \code{@@importFrom hypergeo2 genhypergeo}
#' to \code{R/*-package.R} file, just like \code{\link[Rcpp:Rcpp-package]{Rcpp}}.
#'
#' @return Numeric vector as the results of computation (at \code{double} precision).
#' Warnings are issued if failing to converge.
#'
#' @note Change log:
#' \itemize{
#'   \item{0.1.0 Xiurui Zhu - Initiate the function.}
#'   \item{0.2.0 Xiurui Zhu - Add \code{genhypergeo_cpp()} for non-vectorized implementation in `Rcpp` interface;
#'   limit the return of \code{genhypergeo_vec()} to \code{NumericVector}.}
#'   \item{0.2.1 Xiurui Zhu - Update documentation.}
#' }
#' @author Xiurui Zhu
#'
#' @references For the floating-point datatypes of tunable precision:
#' * Documentation about [\code{mpfr_float}](https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/mpfr_float.html),
#' with datatype \code{boost::multiprecision::number <boost::multiprecision::backends::mpfr_float_backend<0>>}
#' * Documentation about [\code{gmp_float}](https://www.boost.org/doc/libs/master/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/gmp_float.html),
#' with datatype \code{boost::multiprecision::number <boost::multiprecision::backends::gmp_float<0>>}
#' * Documentation about [higher precision of \code{gmp_float} datatype](https://www.mpfr.org/faq.html#:~:text=What%20are%20the%20differences%20between%20MPF%20from%20GMP,minimum%20value%20%28MPF%20generally%20uses%20a%20higher%20precision%29)
#'
#' @export
#'
#' @examples
#' U <- c(-28.2, 11.8, 15.8)
#' L <- c(12.8, 17.8)
#' z <- 1
#' # hypergeo results
#' if (length(find.package("hypergeo", quiet = TRUE)) > 0L) {
#'   hypergeo::genhypergeo(U = U, L = L, z = z)
#' }
#' # Default (double) precision: this may result in cancellation error on some platforms
#' tryCatch(
#'   genhypergeo(U = U, L = L, z = z),
#'   error = function(err) {
#'     if (grepl("Cancellation is so severe that no bits in the result are correct",
#'               conditionMessage(err)) == TRUE) {
#'       message("! Cancellation error on your platform: ",
#'               "you may need a higher [prec] than double ([prec = NULL]): ",
#'               conditionMessage(err))
#'     } else {
#'       stop(err)
#'     }
#'   }
#' )
#' # Precision of 20 digits, default ('mpfr') backend
#' genhypergeo(U = U, L = L, z = z, prec = 20L)
#' # Precision of 20 digits, 'gmp' backend
#' genhypergeo(U = U, L = L, z = z, prec = 20L, backend = "gmp")
#' # Precision of 25 digits, default ('mpfr') backend
#' genhypergeo(U = U, L = L, z = z, prec = 25L)
#' # Precision of 25 digits, 'gmp' backend
#' genhypergeo(U = U, L = L, z = z, prec = 25L, backend = "gmp")
genhypergeo <- function(U, L, z, prec = NULL, check_mode = TRUE, log = FALSE,
                        backend = c("mpfr", "gmp")) {
  backend <- match.arg(backend)
  if (is.list(U) == FALSE) {
    U <- list(U)
  }
  U <- lapply(U, as.numeric)
  if (is.list(L) == FALSE) {
    L <- list(L)
  }
  L <- lapply(L, as.numeric)
  if (is.null(prec) == FALSE) {
    if (is.list(prec) == FALSE) {
      prec <- list(prec)
    }
    prec <- lapply(prec, as.integer)
  }
  if (length(log) == 0L) {
    stop("[log] shoule be logical of length 1, not 0")
  } else if (length(log) > 1L) {
    warning("[log] is of length ", length(log), ": only its first element is used",
            immediate. = TRUE)
  }
  genhypergeo_vec(U = U,
                  L = L,
                  z = as.numeric(z),
                  prec = prec,
                  check_mode = as.logical(check_mode),
                  log = as.logical(log),
                  backend = backend)
}
